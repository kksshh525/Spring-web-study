영속성 관리
=============



### JPA 제공하는 기능
```
1. 엔터티
2. 테이블을 매핑하는 설계부분
3. 매핑하는 엔터티를 실제 사용하는 부분
```

-- 매핑한 엔터티를 EntityManager로 어떻게 사용하는지 알아옴 --
 
> 앤터티 매니저는 앤터티를 CRUD하고 앤터티와 관련된 모든 일을 처리 ( = 엔터티 관리자, = 엔티티를 저장하는 가상의 데이터베이스)
( 하이버 네이트 기준)

데이터 베이스 하나만 사용하는 애플리케이션 = 하나의 EntityManagerFactory

EntityManager = entityManagerFactory.createEntityManager(); <- entityManager의 생산비용은 싸다 (생산시 커넥션 풀도 만듬)

**앤터티 매니저 팩토리는 thread safe**

**앤티티 매니저는 Thread unsafe**

앤티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.


### 영속성 컨텍스트
앤터티 매니저로 저장하거나 조회하면 => 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
**엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장** 

#### 엔티티의 생명주기
1. 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태
2. 영속(managed): 영속성 컨텍스트에 저장된 상태
    1. persist()
3. 준영속(detache): 영속성 컨텍스트에 저장되었다가 분리된 상태
    1. detach() or close(), clear()
4. 삭제(removed):삭제된 상태  
    1. remove()


#### 영속석 컨텍스트 특징
1. 영속성 컨텍스트는 식별자값(@Id)으로 구분 ( 영속상태는 식별자 값이 반드시 있어야 한다)
2. 영속성 컨텍스트와 데이터 베이스 저장은 트랜잭션을 커밋하는 순간 반영 (= flush())

etc) 1차 캐시, 동일성 보장, 트랙잭션 지원 lazy write, 변경감지, lazy loading

#### 1차 캐시
엔티티 조회는 영속성컨텍스트 내부에 1차 캐쉬로 @Id값을 가지고 MAP형태로 저장되어 있다. => 없으면 DB에서 조회 // 1차 캐시 저장후 엔터티 반환
<@Id, entity class type> ( em.find(Member.class, "member"))

* 반복가능한 읽기등급의 트랜잭션 격리수준을 데이터베이스가 아니라 애플리케이션 차원에서 제공하는 장점

#### 동일성 보장
같은 entity type과 Id는 동일함
( 인스턴스가 같다 = Object의 참조하는 값이 같다)

> 동등성 실제 인스턴스는 다르지만 가지고 있는 값이 같다 자바에서는 equals() 메소드를 사용한다.

#### 트랜잭션 지원 쓰기지연
flush()를 통한 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화 
쓰기 지연 SQL 저장소가 있어서 모인 쿼리를 한번에 보낸다.

#### 변경 감지
영속성 컨택스트에서 관리중인 entity의 스냅샷을 가지고 변경된 entity를 자동으로 감지후 수정

update쿼리는 JPA에서 자동으로 생성할때 모든 field를 업데이트하는 쿼리가 만들어지지만
필드가 너무 많아서 수정된 데이터만 사용하는 동적 update sql를 생성하기 위해서는
@entity에 @DynamicUpdate 적용   ( 대략 30개 이상필드에서는 더 빨라짐 )

### 플러시
flush는 영속성 컨텍스트의 변경내용을 데이터베이스에 반영

1. 변경감지 작동: 모든 엔터티를 스냅샷과 비교해서 수정된 엔터티를 찾고 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록
2. 쓰기 지연 SQL저장소의 쿼리를 데이터베이스에 전송

##### Flush 방법 3가지
flush()호출
트랜잭션 커밋 ( 트랜잭션 커밋시 항상 DB에 반영하기 위해 )
JPQL쿼리 실행 ( JPQL, Criteria 객체지향 쿼리실행시 전에 flush ) -> 예를들어 조회결과같은 경우 조회결과를 바로 반영하기 위해서

##### Flush mode option
        em.setFlushMode(FlushModeType.AUTO); (default) -> 커밋이나 쿼리를 실행할떄 플러쉬
        em.setFlushMode(FlushModeType.COMMIT); -> 커밋할때 플러쉬 


### 준영속
```
em.detach
em.clear
em.close
```
준영속에 되면 1차 캐시부터 쓰기지연 SQL저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거 
데이터 베이스에 저장되지도 않는다.

em.clear() 영속성 컨텍스트의 모든 엔티티를 준영속상태로 만든다.

#### 병함
준영속 상태또는 비영속 상태의 엔티티를 다시 새로운 영속 상태의 엔터티를 반환 
merge()