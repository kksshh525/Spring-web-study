### 고급 매핑

* 상속관계 매핑

객체의 상속 관계를 데이터 베이스에 어떻게 매핑하는지

* @MappedSuperclass

등록일, 수정일 같이 여러 엔터티에서 공통으로 사용하는 매핑 정보만 상속받고 싶을떄

* 복힙 키와 식별 관계 매핑

데이터베이스의 식별자가 하나 이상일 떄 매팡하는 방법

* 조인 테이블

테이블은 외래 키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는
연결 테이블을 두는 방법도 있다. 

* 엔터티 하나에 여러 테이블 매핑

보통 엔터티 하나에 테이블하나에 매핑하나 지만 여러 테이블을 매핑하는 방법


#### 상속관계 매핑

관계형 데이터베이스에는 상속이라는 개념 x

대신 *슈퍼타입* *서브타입* 관계라는 모델링 기법이 객체의 상속 개념과 가장 유사하다.

상속관계 매핑 == 슈퍼타입 서브타입 관계를 매핑하는 것

구현 방법
1. 테이블을 각각 만들고 조회할때 조인을 사용

2. 같이 테이블을 하나만 사용해서 통합, JPA에서는 단일 테이블 전략

3. 서비타입 테이블로 변환: 서브 타입마다 하나의 테이블을 만든다.


<hr>

### 조인전략
[소스](./Inheritation.java)

각각을 모두 테이블로 만들고 자식 테읍ㄹ이 부모 테이블의 기본 키를 받아 기본키 + 외래 키로 사용하는 전략
따라서 조회할 때 조인을 자주 사용한다. 객체는 타입으로 구분할 수 있지만
테이블은 타입 개념이 없다. 따라서 타입을 구분하는 칼럼을 추가해야한다.
DTYPE 칼럼을 구분 칼럼으로 사용한다.

장점

* 테이블이 정구화된다
* 외래키의 참조 무결성 제약조걱ㄴ을 활용할 수 있다.
* 저장공간을 효율적으로 사용

단점

* 조회할때 조인이 많이 사용되므로 성능 저하
* 조회 쿼리 복잡
* 데이터를 등록할때 부모, 자식 합해서 insert sql이 두번 일어난다.


### 단일 테이블 전략
[소스](./SingleTablePolicy.java)

단일 테이블 전략 은 테이블 하나만 사용.
그리고 구분 칼럼으로 어떤 자식 데이터가 저장되었는지 구분한다.
조회할때 조인을 사용하지 않으므로 일반적으로 가장 빠르다.

( 주의점: 자식 엔티티가 매핑한 칼럼은 모두 null을 허용해야 한다)

장점

* 조인할 필요 없으니 조회 성능 빠름
* 조회 쿼리 단숨

단점

* 자식 앤터티가 매핑할 칼럼 모두 nullgjdyd
* 테이블이 너무 커져서 조회성능이 오히려 느려질 수 있다.

특징

구분 칼럼을 꼭 사용해야한다. @DiscriminatorColumn()은 꼭 지정해야함
@DiscriminatorValue()은 지정하지 않으면 엔티티 이름을 사용

### 구현 클래스마다 테이블 전략
[소스](./EachTableStrategic.java)
자식 엔티티마다 테이블을 만든다. 자식 테이블 각각에 필요한 칼럼을 만든다.
(DB전문가 및 ORM 전문가는 일반적으로 추천하지 않는 전략)

장점

* 서브 타입을 구분해서 처리할때 효과적
* not null 제약 조건 사용 가능 

단점

* 여러 자식 테이블을 함꼐 조회할때 성능이 느리다
* 자식 테이블을 통합해서 쿼리하기 힘들다.

### @MappedSuperClass
[소스](./MappedSuperC.java)

지금까지는 부모 클래스와 자식 클래스 모두 데이터 베이스 테이블에 매핑했다!!

부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공하고 싶으면
@MappedSuperClass 사용한다. **단순히 매핑정보를 상속할 목적으로만 사용된다.**

* 테이블과 매핑되지 않고 자식 클래스에 엔티티의 매핑정보를 상속하기 위해 사용
* @MappedSuperClass로 지정한 클래스는 엔티티가 아니므로 em, JPQL에서 사용할 수 없다.
* 이 클래스를 직접 생성해서 사용할 일이 거의 없으므로 추상클래스로 만드는것을 권장

### 복합 키와 식별 관계 매핑

데이터 베이스의 테이블 사이에 관계는 외래 키가 기본 키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분한다.

* 식별관계

부모 테이블의 기본키를 내려받아서 자식 테이블의 (기본 키 + 외래 키)로 사용하는 관계

* 비식별 관계

부모 테이블의 기본키를 내려받아서 자식 테이블의 외래키로만 사용하는 관계

1. 필수적 비식별 관계: 외래 키에 NULL을 허용하지 않는다. 부모 클래스와 연관관계를 필수적으로 맺음
2. 선택적 비식별 관계: 외래 키에 NULL을 허용한다. 연관관계를 맺을지 말지 선택할 있다.

최근에는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별관게를 사용하는 추세 

### 복합키: 비 식별관계 매핑
[소스](./CompositKey.java)

JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야 한다.
JPA는 영속성 컨텍스트에 엔티티를 보관할때 엔티티의 식별자를 키로 사용한다. 따라서 식별자를 구분하기위해
equals와 hashcode를 사용해서 동등성을 비교한다.
식별자 필드가 하나일 때는 보통 자바 타입이므로 상관없지만 식별자 필드가 2개 이상이면 별도의 식별자 클래스를 만들고
그곳에 equlas와 hashCode를 구현해야한다.

JPA복합키 지원
1. @IdCLass -> 관계형 DB에 가까운 방식 
2. @EmbeddedId -> 객체지향에 가까운 방식

Embeded가 좀더 객체지향적이고 중복도 없어서 좋아보이긴 하지 아래와같은 JPQL에서 조금더 길어질수있다.
`em.createQuery("select p.id.id1 p.id.id2 from Parent p")` -> embeddedId
`em.createQuery("select p.id1 p.id2 from Parent p")` ->IdClass

### 복합키: 식별관계 매핑
[소스](./CompositKeyIdentity.java)

어렵다.. 하지말자

### 일대일 식별관계

자식 테이블의 기본 키 값으로 부모 테이블 기본 키값만 사용한다.
그래서 부모 테이블의 기본키가 복합키가 아니면 자식테이블의 기본키는 복합키로 구성하지 않아도 된다.

### 식별, 비식별 관계 장단점

식별 관계는 부모 테이블의 기본 키를 자식 테이블로 전파하면서
자식테이블의 기본키 칼럼이 점점 늘어난다 결국 조인할떄 SQL이 복잡해지고 기본 키 인덱스가 불필요하게 커지나

식별 관계는 2개 이상의 칼럼을 합해서 복합 기본키를 만들어야 하는 경우가 많다.

식별 관계는 전파되면 변경되기 힘들다.

 